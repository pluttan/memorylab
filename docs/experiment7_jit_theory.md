# Эксперимент 7: Самомодифицирующийся код (JIT vs Branching)

## Теоретическая основа

### Что такое самомодифицирующийся код?

**Самомодифицирующийся код (Self-Modifying Code, SMC)** — это код, который изменяет собственные инструкции во время выполнения. Это мощная техника оптимизации, используемая в:

- **JIT-компиляторах** (Java, JavaScript V8, .NET CLR)
- **Динамической специализации** кода под конкретные данные
- **Устранении branch misprediction** путём "запекания" констант

### Проблема: Branch Misprediction

Современные процессоры используют **конвейерную обработку (pipelining)**. Когда встречается условный переход, процессор должен предсказать, какая ветвь будет выполнена. При неверном предсказании:

1. Конвейер очищается (pipeline flush)
2. Теряется 10-20 тактов процессора
3. Производительность падает

### Решение: JIT-компиляция

Вместо проверки условия в каждой итерации, JIT-компилятор:

1. Генерирует специализированный машинный код
2. "Запекает" константы прямо в инструкции
3. Устраняет ветвления полностью

## Реализация эксперимента

### Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                         DOOM Engine                          │
├─────────────────────────────────────────────────────────────┤
│  r_draw.c          │  r_jit.c           │  r_main.c         │
│  ───────────────   │  ──────────────    │  ─────────────    │
│  R_DrawColumn()    │  R_JIT_Init()      │  R_JIT_FrameStart │
│  - JIT режим       │  R_JIT_FrameEnd()  │  R_JIT_FrameEnd   │
│  - Branch режим    │  Auto-switch       │                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    jit_benchmark.csv
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    HardwareTester Server                     │
│  self_modifying.cpp: Чтение CSV, расчёт статистики          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Python Client                            │
│  hardware_client.py: Визуализация результатов               │
└─────────────────────────────────────────────────────────────┘
```

### Сравниваемые режимы

#### JIT режим (Loop Unrolling)
```c
// Оптимизированный код: 8x развёртывание цикла
lighttable_t *colormap = dc_colormap;  // Кешируем указатель
byte *source = dc_source;

while (count >= 7) {
    // 8 пикселей за одну итерацию
    *dest = colormap[source[(frac >> FRACBITS) & 127]];
    dest += SCREENWIDTH; frac += fracstep;
    // ... ещё 7 раз ...
    count -= 8;
}
```

**Преимущества:**
- Меньше проверок условия цикла (8x меньше)
- Указатели кешируются в регистрах
- Лучшая предсказуемость переходов

#### Branch режим (Volatile Pointer)
```c
// Неоптимизированный код
do {
    volatile lighttable_t *colormap = dc_colormap;  // Перезагрузка каждую итерацию
    *dest = colormap[dc_source[(frac >> FRACBITS) & 127]];
    dest += SCREENWIDTH;
    frac += fracstep;
} while (count--);
```

**Недостатки:**
- Указатель перезагружается из памяти каждую итерацию
- Больше проверок условия цикла
- Хуже использование кеша

### Метрики

| Метрика | Описание |
|---------|----------|
| frame_time_ms | Время рендеринга одного кадра в миллисекундах |
| draw_calls | Количество вызовов R_DrawColumn за кадр |
| speedup | Отношение времени Branch к времени JIT |

### Автоматическое переключение

Для честного сравнения режимы автоматически переключаются каждую секунду:

```c
if (elapsed >= 1.0) {
    jit_mode_enabled = !jit_mode_enabled;
    last_switch_time = now;
}
```

## Файлы эксперимента

| Файл | Назначение |
|------|------------|
| `doom_src/src/doom/r_jit.c` | Инициализация, таймеры, логирование |
| `doom_src/src/doom/r_jit.h` | Заголовочный файл с API |
| `doom_src/src/doom/r_draw.c` | Функция R_DrawColumn с двумя режимами |
| `doom_src/src/doom/r_main.c` | Вызов R_JIT_FrameStart/End |
| `hardware/experiments/self_modifying.cpp` | Парсинг CSV, расчёт статистики |
| `iu6hardwarememorylab/hardware_client.py` | Функция plot_self_modifying_code |
| `jit_benchmark.csv` | Лог данных бенчмарка |

## Запуск эксперимента

```bash
# Сборка и запуск всего (DOOM + Server + Jupyter)
make run

# Или только DOOM
make doom-build
make doom-run

# Просмотр логов
cat log/doom.log
```

## Ожидаемые результаты

При корректной работе JIT режим должен показать:
- **Меньшее среднее время кадра** (за счёт loop unrolling или JIT)
- **Более стабильное время** (меньше variance)
- **Speedup > 1.0x** относительно Branch режима

## Платформенные особенности

### x86_64 Linux — Реальный JIT

На x86_64 Linux используется **настоящий самомодифицирующийся код**:

```c
// Генерация машинного кода с "запечённым" адресом colormap
void R_JIT_GenerateDrawColumn(const void *colormap) {
    unsigned char *code = (unsigned char *)jit_code;
    uintptr_t cmap_addr = (uintptr_t)colormap;
    
    // mov r12, <64-bit address>  — адрес внедряется прямо в код!
    code[i++] = 0x49; code[i++] = 0xbc;
    memcpy(&code[i], &cmap_addr, 8);  // 8 байт адреса
    
    // Цикл отрисовки с baked address
    // movzx ebx, byte ptr [r12 + rbx]  — загрузка из colormap
    // ... остальные инструкции ...
}
```

**Преимущество**: Адрес colormap запечён в инструкциях, нет необходимости загружать его из памяти каждую итерацию.

### macOS / ARM64 / Другие платформы — Loop Unrolling

На других платформах используется **8x развёртывание цикла**:

```c
while (count >= 7) {
    *dest = colormap[source[(frac >> FRACBITS) & 127]];
    dest += SCREENWIDTH; frac += fracstep;
    // ... повторить 8 раз ...
    count -= 8;
}
```

**Преимущество**: Меньше проверок условия цикла, лучшая предсказуемость переходов.

### Branch режим (базовый)

```c
do {
    volatile lighttable_t *colormap = dc_colormap;  // Перезагрузка!
    *dest = colormap[dc_source[(frac >> FRACBITS) & 127]];
    // ...
} while (count--);
```

**Недостаток**: `volatile` форсирует перезагрузку указателя каждую итерацию.
